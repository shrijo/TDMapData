<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split Terrain Map</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: Arial, sans-serif;
        height: 100vh;
        overflow: hidden;
    }
    
    .container {
        display: flex;
        width: 100%;
        height: 100vh;
    }
    
    .map-container {
        flex: 1;
        height: 100%;
        position: relative;
    }
    
    #colorMap, #heightMap {
        width: 100%;
        height: 100%;
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="map-container">
            <div id="colorMap"></div>
        </div>
        <div class="map-container">
            <div id="heightMap"></div>
        </div>
    </div>

```
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script>
    let colorMap, heightMap;
    let isUpdating = false;

    // Synchronize map movements
    function syncMaps(sourceMap, targetMap) {
        if (isUpdating) return;
        isUpdating = true;
        
        const center = sourceMap.getCenter();
        const zoom = sourceMap.getZoom();
        
        targetMap.setView(center, zoom, { animate: false });
        
        setTimeout(() => {
            isUpdating = false;
        }, 100);
    }

    // Initialize both maps
    function initializeMaps() {
        // Color map (left side) - using World Imagery for color data
        colorMap = L.map('colorMap', {
            center: [46.8182, 8.2275], // Switzerland as default
            zoom: 8,
            zoomControl: false
        });

        // Add World Imagery basemap for color data
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri'
        }).addTo(colorMap);

        // Height map (right side) - using the terrain layer you provided
        heightMap = L.map('heightMap', {
            center: [46.8182, 8.2275], // Switzerland as default
            zoom: 8,
            zoomControl: false
        });

        // Add the ArcGIS terrain layer for height data
        L.tileLayer('https://tiles.arcgis.com/tiles/nGt4QxSblgDfeJn9/arcgis/rest/services/terrain_with_heavy_bathymetry/MapServer/tile/{z}/{y}/{x}', {
            attribution: '&copy; Esri'
        }).addTo(heightMap);

        // Sync map movements
        colorMap.on('moveend zoomend', function() {
            syncMaps(colorMap, heightMap);
        });

        heightMap.on('moveend zoomend', function() {
            syncMaps(heightMap, colorMap);
        });

        // Additional synchronization for drag events
        colorMap.on('move', function() {
            if (!isUpdating) {
                const center = colorMap.getCenter();
                const zoom = colorMap.getZoom();
                heightMap.setView(center, zoom, { animate: false });
            }
        });

        heightMap.on('move', function() {
            if (!isUpdating) {
                const center = heightMap.getCenter();
                const zoom = heightMap.getZoom();
                colorMap.setView(center, zoom, { animate: false });
            }
        });
    }

    // Initialize when page loads
    window.addEventListener('load', function() {
        setTimeout(initializeMaps, 100);
    });

    // Handle window resize
    window.addEventListener('resize', function() {
        if (colorMap && heightMap) {
            colorMap.invalidateSize();
            heightMap.invalidateSize();
        }
    });

    // API for TouchDesigner integration
    window.getMapData = function() {
        if (!colorMap || !heightMap) return null;
        
        const bounds = colorMap.getBounds();
        const center = colorMap.getCenter();
        const zoom = colorMap.getZoom();
        
        return {
            center: [center.lat, center.lng],
            zoom: zoom,
            bounds: {
                north: bounds.getNorth(),
                south: bounds.getSouth(),
                east: bounds.getEast(),
                west: bounds.getWest()
            }
        };
    };

    window.setMapView = function(lat, lng, zoom) {
        if (colorMap && heightMap) {
            isUpdating = true;
            colorMap.setView([lat, lng], zoom);
            heightMap.setView([lat, lng], zoom);
            setTimeout(() => {
                isUpdating = false;
            }, 100);
        }
    };
</script>
```

</body>
</html>